package fi.helsinki.cs.gradubot.production.optimize.solutions.antcolony;import fi.helsinki.cs.gradubot.production.optimize.framework.AbstractBuildOptimizer;import fi.helsinki.cs.gradubot.production.optimize.framework.Node;import fi.helsinki.cs.gradubot.production.optimize.framework.RequiredTypes;import fi.helsinki.cs.gradubot.production.optimize.framework.Solution;import fi.helsinki.cs.gradubot.production.optimize.framework.branchcutting.BranchCutStrategy;import fi.helsinki.cs.gradubot.production.optimize.framework.branchcutting.pareto.ParetoCutter2;import fi.helsinki.cs.gradubot.production.optimize.framework.simulation.InvalidStateException;import java.util.*;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class BuildOptimizerBasicAntColonyImpl extends AbstractBuildOptimizer<AntNode> {    public static int MAX_ITERATIONS = 9999999;    public boolean USE_PARETO_CUT = false;    public int iteration = 0;    private int antCount = 100;    private double depositRatio = 1;    private double evaporationRatio = 0.01;    private double minPheromone = 0.35;    private double maxPheromone = 11;    private double goForHighestChance = 0.35;    private double pheromoneExp = 1.0;    private double attractivenessHeuristic1Exp = 5;    private double attractivenessHeuristic2Exp = 1.1;    private double attractivenessHeuristic3Exp = 0.3;    private int bestBeforeThisRound;    public List<Ant> ants;    private static final int THREAD_COUNT = 1;    private static ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);    public boolean pheromoneUpdateEnabled = true;    private ParetoCutter2 paretoCutter;    public BuildOptimizerBasicAntColonyImpl(RequiredTypes requiredTypes, List<BranchCutStrategy> branchCutStrategies, Solution externalBestSolution) {        super(requiredTypes, branchCutStrategies, externalBestSolution);    }    @Override    public void start() {        super.start();        populateAnts(antCount);        if(USE_PARETO_CUT) {            paretoCutter = new ParetoCutter2(requiredTypes);            paretoCutter.addNode(root);        }        AntNode.evaporationRatio = evaporationRatio;        AntNode.minPheromone = minPheromone;        AntNode.maxPheromone = maxPheromone;    }    public void populateAnts(int antCount){        List<Double> attrExps = new ArrayList<>();        attrExps.add(attractivenessHeuristic1Exp);        attrExps.add(attractivenessHeuristic2Exp);        attrExps.add(attractivenessHeuristic3Exp);        ants = new ArrayList<>(antCount);        for(int i=0; i<antCount; i++){            Ant ant = new Ant(requiredTypes, attrExps);            ant.pherExp = pheromoneExp;            ant.goForHighestChance = goForHighestChance;            ants.add(ant);        }    }    public void setAnts(List<Ant> ants){        this.ants = ants;    }    @Override    public void runIteration() {        super.runIteration();        if(iteration == MAX_ITERATIONS){            setRunning(false);            return;        }        bestBeforeThisRound = bestSolution.getTime();        List<AntRunner> antRunners = new ArrayList<>(ants.size());        for(Ant ant : ants){            antRunners.add(new AntRunner(ant));        }        invokeAntRunners(antRunners);        antRunners.clear();        for(Ant ant : ants){            removeNodeAndChildlessAncestorsFromTree(ant);        }        if(pheromoneUpdateEnabled)            pheromoneUpdate();        for(Ant ant : ants){            ant.path.clear();            ant.currentNode = null;        }        iteration++;    }    private int treeSize(Node first) {        Stack<Node> stack = new Stack<>();        stack.push(first);        int children = 0;        while (!stack.isEmpty()){            Node node = stack.pop();            children++;            if(node.children != null)                stack.addAll(node.children);        }        return children;    }    private void invokeAntRunners(List<AntRunner> antRunners) {        try {            executor.invokeAll(antRunners);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    private class AntRunner implements Callable<Object> {        private Ant ant;        private AntRunner(Ant ant) {            this.ant = ant;        }        @Override        public Object call() {            try {                ant.reset();                findSolution(ant);                if (ant.solution != null) {                    if(bestSolution == null || ant.solution.isBetterThan(bestSolution)){                        bestSolution = ant.solution;                    }                }            } catch (Exception e){                e.printStackTrace();                System.out.println("ERROR IN CALLABLE");            }            return null;        }    }    private void removeNodeAndChildlessAncestorsFromTree(Ant ant) {        Node node = ant.path.pop();        if (node.equals(root)) {            setRunning(false);            return;        }        node.parent.children.remove(node);        while (!ant.path.isEmpty()){            node = ant.path.pop();            node.removeCutChildren();            if(node.children.size() == 0) {                node.cut = true;            } else return;        }    }    private void pheromoneUpdate() {        pheromoneDepositBestAntsOnly();    }    private void pheromoneDepositBestAntsOnly() {        Collections.sort(ants, new Comparator<Ant>() {            @Override            public int compare(Ant o1, Ant o2) {                if (o1.solution == null && o2.solution == null) {                    if (o1.getPercentComplete() > o2.getPercentComplete()) return -1;                    if (o1.getPercentComplete() < o2.getPercentComplete()) return 1;                    return 0;                }                if (o1.solution != null && o2.solution == null) return -1;                if (o1.solution == null && o2.solution != null) return 1;                if (o1.solution.getTime() < o2.solution.getTime()) return -1;                if (o1.solution.getTime() > o2.solution.getTime()) return 1;                return 0;            }        });        int antsToDeposit = antCount / 10;        if(antsToDeposit < 1) antsToDeposit = 1;        for(int i=0; i<antsToDeposit; i++){            Ant ant = ants.get(i);            double pheromoneAdd = 0;            if (ant.solution == null) {                pheromoneAdd = Math.pow(ant.getPercentComplete(), 2);            }            else {                if(ant.solution.getTime() < bestBeforeThisRound) {                    pheromoneAdd = 2 + 5.0 * (bestBeforeThisRound - ant.solution.getTime()) / bestBeforeThisRound;                }                else{                    pheromoneAdd = 0.5 + Math.pow(1.0 * bestBeforeThisRound / ant.solution.getTime(), 2);                }            }            pheromoneAdd /= Math.sqrt(i+1);            pheromoneAdd *= depositRatio;            ant.fitness += pheromoneAdd;            AntNode node;            while (!ant.path.isEmpty()) {                node = ant.path.pop();                node.evaporate(iteration);                node.deposit(pheromoneAdd);            }        }    }    private void findSolution(Ant ant) {        ant.moveToNode(root);        while (!ant.finished && isRunning()){            handleNode(ant);        }    }    private static int cut1 = 0;    private static int cut2 = 0;    private static int nodes = 0;    private void handleNode(Ant ant) {        if(!isRunning()) return;        synchronized (ant.currentNode){            if(areGoalsReached(ant.currentNode)){                ant.solutionFound();                ant.currentNode.cut = true;                return;            }            if(shouldBranchBeCut(ant.currentNode)){                ant.die();                ant.currentNode.cut = true;                return;            }            if(ant.currentNode.children == null) {                if(USE_PARETO_CUT && paretoCutter.isThisNodeDominated(ant.currentNode)){                    ant.die();                    ant.currentNode.cut = true;                    paretoCutter.removeSubTree(ant.currentNode);                    cut1++;                    return;                }                if(USE_PARETO_CUT){                    List<Node> dominatedNodes = paretoCutter.nodesDominatedByThis(ant.currentNode);                    for(Node dominated : dominatedNodes){                        dominated.cut = true;                        cut2++;                        paretoCutter.removeSubTree(dominated);                    }                }                childGeneration(ant);                if(USE_PARETO_CUT) {                    for (Node child : ant.currentNode.children) {                        paretoCutter.addNode(child);                    }                }            }            ant.currentNode.removeCutChildren();            if(ant.currentNode.children.size() == 0){                ant.currentNode.cut = true;                if(ant.currentNode.getId() == root.getId()){                    ant.finished = true;                    setRunning(false);                }                else                    ant.reverse();                return;            }            Node nextNode = ant.chooseNextAction(iteration);            ant.moveToNode((AntNode) nextNode);        }    }    private void childGeneration(Ant ant) {        ant.currentNode.generateChildNodes(requiredTypes);        ListIterator<Node> childIterator = ant.currentNode.children.listIterator();        AntNode child;        while (childIterator.hasNext()){            child = (AntNode) childIterator.next();            try {                child.copyStateAndSimulateAction();                child.lastEvaporation = iteration;            }            catch (InvalidStateException e){                childIterator.remove();            }        }    }    public void setParameters(int antCount, double depositRatio, double evaporationRatio, double minPheromone, double maxPheromone, double goForHighestChance,                              double pheromoneExp, double attractivenessHeuristic1Exp, double attractivenessHeuristic2Exp, double attractivenessHeuristic3Exp) {        this.antCount = antCount;        this.depositRatio = depositRatio;        this.evaporationRatio = evaporationRatio;        this.minPheromone = minPheromone;        this.maxPheromone = maxPheromone;        this.goForHighestChance = goForHighestChance;        this.pheromoneExp = pheromoneExp;        this.attractivenessHeuristic1Exp = attractivenessHeuristic1Exp;        this.attractivenessHeuristic2Exp = attractivenessHeuristic2Exp;        this.attractivenessHeuristic3Exp = attractivenessHeuristic3Exp;        AntNode.evaporationRatio = evaporationRatio;        AntNode.minPheromone = minPheromone;        AntNode.maxPheromone = maxPheromone;    }    public double getDepositRatio() {        return depositRatio;    }    public void setDepositRatio(double depositRatio) {        this.depositRatio = depositRatio;    }    public double getEvaporationRatio() {        return evaporationRatio;    }    public void setEvaporationRatio(double evaporationRatio) {        this.evaporationRatio = evaporationRatio;    }    public double getMinPheromone() {        return minPheromone;    }    public void setMinPheromone(double minPheromone) {        this.minPheromone = minPheromone;    }    public double getMaxPheromone() {        return maxPheromone;    }    public void setMaxPheromone(double maxPheromone) {        this.maxPheromone = maxPheromone;    }    public double getGoForHighestChance() {        return goForHighestChance;    }    public void setGoForHighestChance(double goForHighestChance) {        this.goForHighestChance = goForHighestChance;    }    public double getPheromoneExp() {        return pheromoneExp;    }    public void setPheromoneExp(double pheromoneExp) {        this.pheromoneExp = pheromoneExp;    }    public double getAttractivenessHeuristic1Exp() {        return attractivenessHeuristic1Exp;    }    public void setAttractivenessHeuristic1Exp(double attractivenessHeuristic1Exp) {        this.attractivenessHeuristic1Exp = attractivenessHeuristic1Exp;    }    public double getAttractivenessHeuristic2Exp() {        return attractivenessHeuristic2Exp;    }    public void setAttractivenessHeuristic2Exp(double attractivenessHeuristic2Exp) {        this.attractivenessHeuristic2Exp = attractivenessHeuristic2Exp;    }    public double getAttractivenessHeuristic3Exp() {        return attractivenessHeuristic3Exp;    }    public void setAttractivenessHeuristic3Exp(double attractivenessHeuristic3Exp) {        this.attractivenessHeuristic3Exp = attractivenessHeuristic3Exp;    }    public List<Ant> getAnts() {        return ants;    }}